// 哈希函数 将字符串转化为大数字
// 哈希化 大数字转化为数组可接受下标的数字过程
// 哈希表 将数据插入到的这个数组，对整个结构的封装，我们称之为一个哈希表
// 
// 哈希化和哈希函数也有可能造成冲突
// 避免冲突的方法
// 1 链地址发 2 开放地址发
// 1 数组中不存放一个单一的元素 可能是数组或者链表
// 2 开放地址法 一旦发生冲突则寻找空白单元格查找
    // A 线性查找 index + 1 查询时，如果下标不相同，则仿照前一步不断增加index
    //          删除时候，不可将这个位置的下标设置为null，因为下次查找时，一旦这个位置为空，则函数返回，影响查询结果
    //          可以设置为特殊元素，如 -1
    // 缺点 线性聚集 插入一系列连续的元素时候
    // B 二次探测 一次探测做很大步长 index + 1^2； index + 2^2 index + 3^2 
    // 缺点 会造成步长较长的聚集
    // C 再哈希法 利用一个不同的哈希函数在做一次哈希化，用这次哈希化的记过作为步长
    // 不同的关键字即使映射到相同的数组下标，也可以使用不同的探测序列

// 好的哈希函数 1 快速的计算（霍纳法则）尽可能减少乘法 O(N^2)=>O(N) 2 均匀的分布（元素尽可能均匀的分布）

// 哈希函数
function hashFunc(str, size) {
    // 定义hash code 变量
    var hashCode = 0;
    // 霍纳法则
    // charCodeAt => Unicode编码
    for (var i = 0; i < str.length; i++){
        hashCode = 37 * hashCode + str.charCodeAt(i);
    }
    // 取余操作
    var index = hashCode % index;
    return index;
}


